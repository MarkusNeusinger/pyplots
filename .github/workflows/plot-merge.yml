name: "Plot: Merge"
run-name: "Merge: ${{ github.event.inputs.pr_number || github.event.pull_request.head.ref || 'push' }}"

# Auto-merge PRs when ai-approved label is added
# Also handles feature branch → main merge when all libraries complete

on:
  pull_request:
    types: [labeled, closed]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to auto-merge'
        required: true
        type: number

jobs:
  # ============================================================================
  # Job 1: Enable auto-merge when ai-approved label is added or dispatched
  # ============================================================================
  auto-merge:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Check conditions
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Handle workflow_dispatch trigger
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            PR_NUM="${{ github.event.inputs.pr_number }}"
            PR_DATA=$(gh pr view "$PR_NUM" --repo ${{ github.repository }} --json headRefName,labels)
            BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')
            HAS_APPROVED=$(echo "$PR_DATA" | jq -r '.labels[].name' | grep -c "ai-approved" || echo "0")

            if [[ ! "$BRANCH" =~ ^auto/ ]]; then
              echo "::notice::Skipping: Branch '$BRANCH' is not auto/*"
              echo "should_run=false" >> $GITHUB_OUTPUT
              exit 0
            fi

            if [[ "$HAS_APPROVED" == "0" ]]; then
              echo "::notice::Skipping: PR does not have ai-approved label"
              echo "should_run=false" >> $GITHUB_OUTPUT
              exit 0
            fi

            echo "pr_number=$PR_NUM" >> $GITHUB_OUTPUT
            echo "branch=$BRANCH" >> $GITHUB_OUTPUT
            echo "should_run=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Handle pull_request labeled trigger
          ACTION="${{ github.event.action }}"
          LABEL="${{ github.event.label.name }}"
          BRANCH="${{ github.event.pull_request.head.ref }}"

          if [[ "$ACTION" != "labeled" ]]; then
            echo "::notice::Skipping: Action is '$ACTION', not 'labeled'"
            echo "should_run=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [[ "$LABEL" != "ai-approved" ]]; then
            echo "::notice::Skipping: Label is '$LABEL', not 'ai-approved'"
            echo "should_run=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [[ ! "$BRANCH" =~ ^auto/ ]]; then
            echo "::notice::Skipping: Branch '$BRANCH' is not auto/*"
            echo "should_run=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "should_run=true" >> $GITHUB_OUTPUT

      - name: Checkout repository
        if: steps.check.outputs.should_run == 'true'
        uses: actions/checkout@v6

      - name: Extract info from branch
        if: steps.check.outputs.should_run == 'true'
        id: extract
        run: |
          BRANCH="${{ steps.check.outputs.branch }}"
          # Format: auto/{spec-id}/{library}
          SPEC_ID=$(echo "$BRANCH" | cut -d'/' -f2)
          LIBRARY=$(echo "$BRANCH" | cut -d'/' -f3)

          echo "spec_id=$SPEC_ID" >> $GITHUB_OUTPUT
          echo "library=$LIBRARY" >> $GITHUB_OUTPUT

      - name: Get main issue from PR body
        if: steps.check.outputs.should_run == 'true'
        id: main_issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUM="${{ steps.check.outputs.pr_number }}"
          SPEC_ID="${{ steps.extract.outputs.spec_id }}"
          PR_BODY=$(gh pr view "$PR_NUM" --json body -q '.body' 2>/dev/null || echo "")

          # Extract main issue from PR body
          MAIN_ISSUE=$(echo "$PR_BODY" | grep -oP '\*\*Parent Issue:\*\* #\K\d+' | head -1 || echo "")

          # Fallback: search for main issue
          if [ -z "$MAIN_ISSUE" ]; then
            MAIN_ISSUE=$(gh issue list --label plot-request --search "$SPEC_ID in:title" --json number -q '.[0].number' 2>/dev/null || echo "")
          fi

          echo "number=$MAIN_ISSUE" >> $GITHUB_OUTPUT
          echo "Main issue: #$MAIN_ISSUE"

      - name: React with rocket emoji
        if: steps.check.outputs.should_run == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh api repos/${{ github.repository }}/issues/${{ steps.check.outputs.pr_number }}/reactions \
            -f content=rocket

      - name: Merge PR directly
        if: steps.check.outputs.should_run == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr merge ${{ steps.check.outputs.pr_number }} \
            --repo ${{ github.repository }} \
            --squash \
            --delete-branch

      - name: Extract quality score from PR labels
        if: steps.check.outputs.should_run == 'true'
        id: quality
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUM="${{ steps.check.outputs.pr_number }}"

          # Get quality score from label (format: score:XX)
          LABELS=$(gh pr view "$PR_NUM" --json labels -q '.labels[].name' 2>/dev/null || echo "")
          SCORE=$(echo "$LABELS" | grep -oP 'score:\K\d+' | head -1 || echo "")

          if [ -n "$SCORE" ]; then
            echo "score=$SCORE" >> $GITHUB_OUTPUT
            echo "Quality score: $SCORE"
          else
            echo "score=" >> $GITHUB_OUTPUT
            echo "No quality score found in labels"
          fi

      - name: Checkout feature branch for metadata update
        if: steps.check.outputs.should_run == 'true'
        uses: actions/checkout@v6
        with:
          ref: plot/${{ steps.extract.outputs.spec_id }}
          fetch-depth: 0

      - name: Update metadata.yaml for this library
        if: steps.check.outputs.should_run == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SPEC_ID: ${{ steps.extract.outputs.spec_id }}
          LIBRARY: ${{ steps.extract.outputs.library }}
          MAIN_ISSUE: ${{ steps.main_issue.outputs.number }}
          QUALITY_SCORE: ${{ steps.quality.outputs.score }}
          PR_NUM: ${{ steps.check.outputs.pr_number }}
        run: |
          METADATA_FILE="plots/${SPEC_ID}/metadata.yaml"

          # Install yq for YAML manipulation
          wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod +x /usr/local/bin/yq

          # Ensure implementations section exists
          yq -i '.implementations = (.implementations // {})' "$METADATA_FILE"
          yq -i ".implementations.${LIBRARY} = (.implementations.${LIBRARY} // {})" "$METADATA_FILE"
          yq -i ".implementations.${LIBRARY}.current = (.implementations.${LIBRARY}.current // {})" "$METADATA_FILE"

          # Update this library's metadata
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          yq -i ".implementations.${LIBRARY}.preview_url = \"https://storage.googleapis.com/pyplots-images/plots/${SPEC_ID}/${LIBRARY}/plot.png\"" "$METADATA_FILE"
          yq -i ".implementations.${LIBRARY}.current.generated_at = \"${TIMESTAMP}\"" "$METADATA_FILE"
          yq -i ".implementations.${LIBRARY}.current.generated_by = \"claude-opus-4-5-20251101\"" "$METADATA_FILE"
          yq -i ".implementations.${LIBRARY}.current.workflow_run = ${{ github.run_id }}" "$METADATA_FILE"
          yq -i ".implementations.${LIBRARY}.current.issue = ${MAIN_ISSUE:-0}" "$METADATA_FILE"

          if [ -n "$QUALITY_SCORE" ]; then
            yq -i ".implementations.${LIBRARY}.current.quality_score = ${QUALITY_SCORE}" "$METADATA_FILE"
          fi

          echo "Updated metadata for ${LIBRARY}:"
          cat "$METADATA_FILE"

          # Commit and push
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add "$METADATA_FILE"
          if ! git diff --cached --quiet; then
            git commit -m "chore(${LIBRARY}): update metadata for ${SPEC_ID}"
            git push origin "plot/${SPEC_ID}"
            echo "::notice::Metadata updated for ${LIBRARY}"
          else
            echo "::notice::No metadata changes for ${LIBRARY}"
          fi

      - name: Post progress to main issue
        if: steps.check.outputs.should_run == 'true' && steps.main_issue.outputs.number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          MAIN_ISSUE="${{ steps.main_issue.outputs.number }}"
          LIBRARY="${{ steps.extract.outputs.library }}"
          SPEC_ID="${{ steps.extract.outputs.spec_id }}"
          PR_NUM="${{ steps.check.outputs.pr_number }}"

          gh issue comment "$MAIN_ISSUE" --body "## :white_check_mark: $LIBRARY Merged

          **$LIBRARY** implementation for \`$SPEC_ID\` has been merged to the feature branch.

          **PR:** #$PR_NUM

          ---
          :robot: *[plot-merge workflow](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

  # ============================================================================
  # Job 2: Post-merge check - see if all libraries are done
  # ============================================================================
  check-complete:
    needs: auto-merge
    if: always() && needs.auto-merge.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Get info from previous job
        id: info
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # We need to re-extract info since jobs don't share outputs easily
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            PR_NUM="${{ github.event.inputs.pr_number }}"
          else
            PR_NUM="${{ github.event.pull_request.number }}"
          fi

          PR_DATA=$(gh pr view "$PR_NUM" --repo ${{ github.repository }} --json headRefName,body 2>/dev/null || echo "{}")
          BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName // empty')

          if [ -z "$BRANCH" ] || [[ ! "$BRANCH" =~ ^auto/ ]]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          SPEC_ID=$(echo "$BRANCH" | cut -d'/' -f2)
          PR_BODY=$(echo "$PR_DATA" | jq -r '.body // empty')
          MAIN_ISSUE=$(echo "$PR_BODY" | grep -oP '\*\*Parent Issue:\*\* #\K\d+' | head -1 || echo "")

          if [ -z "$MAIN_ISSUE" ]; then
            MAIN_ISSUE=$(gh issue list --label plot-request --search "$SPEC_ID in:title" --json number -q '.[0].number' 2>/dev/null || echo "")
          fi

          echo "spec_id=$SPEC_ID" >> $GITHUB_OUTPUT
          echo "main_issue=$MAIN_ISSUE" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT

      - name: Check if all libraries are done
        if: steps.info.outputs.skip != 'true' && steps.info.outputs.main_issue != ''
        id: check_complete
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SPEC_ID="${{ steps.info.outputs.spec_id }}"
          MAIN_ISSUE="${{ steps.info.outputs.main_issue }}"

          # Count PRs for this spec
          # All library PRs target plot/{spec-id} branch
          FEATURE_BRANCH="plot/$SPEC_ID"

          # Get all PRs targeting the feature branch
          ALL_PRS=$(gh pr list --base "$FEATURE_BRANCH" --state all --json number,state,mergedAt,labels -q '.' 2>/dev/null || echo "[]")

          TOTAL=$(echo "$ALL_PRS" | jq 'length')
          MERGED=$(echo "$ALL_PRS" | jq '[.[] | select(.mergedAt != null)] | length')
          NOT_FEASIBLE=$(echo "$ALL_PRS" | jq '[.[] | select(any(.labels[]?; .name == "not-feasible"))] | length')

          echo "total=$TOTAL" >> $GITHUB_OUTPUT
          echo "merged=$MERGED" >> $GITHUB_OUTPUT
          echo "not_feasible=$NOT_FEASIBLE" >> $GITHUB_OUTPUT

          # We expect 9 libraries
          DONE=$((MERGED + NOT_FEASIBLE))
          if [ "$DONE" -ge 9 ]; then
            echo "all_done=true" >> $GITHUB_OUTPUT
          else
            echo "all_done=false" >> $GITHUB_OUTPUT
          fi

          echo "Progress: $DONE/9 complete ($MERGED merged, $NOT_FEASIBLE not feasible)"

      - name: Checkout feature branch
        if: steps.info.outputs.skip != 'true' && steps.check_complete.outputs.all_done == 'true' && steps.info.outputs.main_issue != ''
        uses: actions/checkout@v6
        with:
          ref: plot/${{ steps.info.outputs.spec_id }}
          fetch-depth: 0

      - name: Verify metadata exists
        if: steps.info.outputs.skip != 'true' && steps.check_complete.outputs.all_done == 'true' && steps.info.outputs.main_issue != ''
        run: |
          SPEC_ID="${{ steps.info.outputs.spec_id }}"
          METADATA_FILE="plots/${SPEC_ID}/metadata.yaml"

          # Note: Per-library metadata updates happen in the auto-merge job
          # This step just verifies the metadata file exists
          if [ -f "$METADATA_FILE" ]; then
            echo "Metadata file exists:"
            cat "$METADATA_FILE"
          else
            echo "::warning::Metadata file not found: $METADATA_FILE"
          fi

      - name: Create and merge feature-to-main PR
        if: steps.info.outputs.skip != 'true' && steps.check_complete.outputs.all_done == 'true' && steps.info.outputs.main_issue != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SPEC_ID="${{ steps.info.outputs.spec_id }}"
          MAIN_ISSUE="${{ steps.info.outputs.main_issue }}"
          MERGED="${{ steps.check_complete.outputs.merged }}"
          NOT_FEASIBLE="${{ steps.check_complete.outputs.not_feasible }}"

          # Check if main issue already completed
          LABELS=$(gh issue view "$MAIN_ISSUE" --json labels -q '.labels[].name' 2>/dev/null || echo "")
          if echo "$LABELS" | grep -q "completed"; then
            echo "Main issue #$MAIN_ISSUE already completed"
            exit 0
          fi

          # Check if feature branch exists
          if ! gh api repos/${{ github.repository }}/branches/plot/$SPEC_ID &>/dev/null; then
            echo "Feature branch plot/$SPEC_ID does not exist, skipping"
            exit 0
          fi

          # Check if PR already exists
          EXISTING_PR=$(gh pr list --base main --head "plot/$SPEC_ID" --json number -q '.[0].number' 2>/dev/null || echo "")
          if [ -n "$EXISTING_PR" ]; then
            echo "PR #$EXISTING_PR already exists for plot/$SPEC_ID -> main"
            gh pr merge "$EXISTING_PR" --squash --delete-branch --auto 2>/dev/null || true
            FEATURE_PR="$EXISTING_PR"
          else
            # Create PR from feature branch to main
            FEATURE_PR=$(gh pr create \
              --base main \
              --head "plot/$SPEC_ID" \
              --title "feat: add $SPEC_ID implementation ($MERGED libraries)" \
              --body "## Summary
          Adds \`$SPEC_ID\` plot implementation.

          ### Libraries
          - **Merged:** $MERGED
          - **Not Feasible:** $NOT_FEASIBLE

          ### Links
          - **Spec:** \`plots/$SPEC_ID/spec.md\`
          - **Parent Issue:** #$MAIN_ISSUE

          Closes #$MAIN_ISSUE

          ---
          :robot: *Auto-generated by pyplots CI*" | sed 's|.*/||')

            echo "Created PR #$FEATURE_PR"

            # Enable auto-merge
            gh pr merge "$FEATURE_PR" --squash --delete-branch --auto 2>/dev/null || true
          fi

          # Build image gallery for the issue comment
          LIBRARIES="matplotlib seaborn plotnine plotly bokeh altair highcharts pygal letsplot"
          GALLERY=""

          for lib in $LIBRARIES; do
            IMG_URL="https://storage.googleapis.com/pyplots-images/staging/${SPEC_ID}/${lib}/plot.png"
            GALLERY="${GALLERY}
          ### ${lib}
          ![${lib}](${IMG_URL})"
          done

          # Post completion to main issue with gallery
          if [ "$NOT_FEASIBLE" -gt 0 ]; then
            STATUS_MSG="$MERGED libraries ready, $NOT_FEASIBLE not feasible"
          else
            STATUS_MSG="All $MERGED libraries ready"
          fi

          gh issue comment "$MAIN_ISSUE" --body "## :tada: All Libraries Complete!

          **Status:** $STATUS_MSG
          **Feature PR:** #$FEATURE_PR (auto-merge enabled)

          ---

          ## Preview Gallery
          ${GALLERY}

          ---
          :rocket: *[plot-merge workflow](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

          # Add completed label
          gh issue edit "$MAIN_ISSUE" --add-label "completed" 2>/dev/null || true

  # ============================================================================
  # Job 3: Handle PR close events (for tracking)
  # ============================================================================
  post-merge-summary:
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: read

    steps:
      - name: Check conditions
        id: check
        run: |
          BRANCH="${{ github.event.pull_request.head.ref }}"

          if [[ ! "$BRANCH" =~ ^auto/ ]]; then
            echo "::notice::Skipping: Branch '$BRANCH' is not auto/*"
            echo "should_run=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "should_run=true" >> $GITHUB_OUTPUT

      - name: Extract info
        if: steps.check.outputs.should_run == 'true'
        id: extract
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="${{ github.event.pull_request.head.ref }}"
          PR_NUM="${{ github.event.pull_request.number }}"
          PR_BODY=$(gh pr view "$PR_NUM" --json body -q '.body' 2>/dev/null || echo "")

          # Format: auto/{spec-id}/{library}
          SPEC_ID=$(echo "$BRANCH" | cut -d'/' -f2)
          LIBRARY=$(echo "$BRANCH" | cut -d'/' -f3)

          # Extract main issue from PR body
          MAIN_ISSUE=$(echo "$PR_BODY" | grep -oP '\*\*Parent Issue:\*\* #\K\d+' | head -1 || echo "")

          # Fallback: search for main issue
          if [ -z "$MAIN_ISSUE" ]; then
            MAIN_ISSUE=$(gh issue list --label plot-request --search "$SPEC_ID in:title" --json number -q '.[0].number' || echo "")
          fi

          echo "spec_id=$SPEC_ID" >> $GITHUB_OUTPUT
          echo "library=$LIBRARY" >> $GITHUB_OUTPUT
          echo "main_issue=$MAIN_ISSUE" >> $GITHUB_OUTPUT

      - name: Post merge notification
        if: steps.check.outputs.should_run == 'true' && steps.extract.outputs.main_issue != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          MAIN_ISSUE="${{ steps.extract.outputs.main_issue }}"
          LIBRARY="${{ steps.extract.outputs.library }}"
          SPEC_ID="${{ steps.extract.outputs.spec_id }}"
          PR_NUM="${{ github.event.pull_request.number }}"

          # Check if we already posted (avoid duplicates)
          EXISTING=$(gh issue view "$MAIN_ISSUE" --json comments -q "[.comments[].body | select(contains(\"$LIBRARY Merged\") and contains(\"#$PR_NUM\"))] | length" 2>/dev/null || echo "0")

          if [ "$EXISTING" != "0" ]; then
            echo "Already posted merge notification for $LIBRARY"
            exit 0
          fi

          gh issue comment "$MAIN_ISSUE" --body "## :white_check_mark: $LIBRARY Merged

          **$LIBRARY** implementation for \`$SPEC_ID\` has been merged!

          **PR:** #$PR_NUM

          ---
          :robot: *pyplots CI*"

  # ============================================================================
  # Job 4: Move GCS images from staging to production (when feature→main merged)
  # ============================================================================
  promote-to-production:
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Check if feature-to-main merge
        id: check
        run: |
          BRANCH="${{ github.event.pull_request.head.ref }}"
          BASE="${{ github.event.pull_request.base.ref }}"

          # Only run for plot/{spec-id} → main merges
          if [[ "$BASE" != "main" ]]; then
            echo "::notice::Skipping: Base is '$BASE', not 'main'"
            echo "should_run=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [[ ! "$BRANCH" =~ ^plot/ ]]; then
            echo "::notice::Skipping: Branch '$BRANCH' is not plot/*"
            echo "should_run=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract spec-id from branch name: plot/{spec-id}
          SPEC_ID=$(echo "$BRANCH" | cut -d'/' -f2)
          echo "spec_id=$SPEC_ID" >> $GITHUB_OUTPUT
          echo "should_run=true" >> $GITHUB_OUTPUT
          echo "::notice::Feature branch merged to main: $SPEC_ID"

      - name: Setup Google Cloud authentication
        if: steps.check.outputs.should_run == 'true'
        uses: google-github-actions/auth@v3
        with:
          credentials_json: ${{ secrets.GCS_CREDENTIALS }}

      - name: Setup gcloud CLI
        if: steps.check.outputs.should_run == 'true'
        uses: google-github-actions/setup-gcloud@v3

      - name: Move images from staging to production
        if: steps.check.outputs.should_run == 'true'
        run: |
          SPEC_ID="${{ steps.check.outputs.spec_id }}"
          STAGING="gs://pyplots-images/staging/${SPEC_ID}"
          PRODUCTION="gs://pyplots-images/plots/${SPEC_ID}"

          echo "Moving images from staging to production for $SPEC_ID"

          # Copy from staging to production (preserving structure)
          gsutil -m cp -r "${STAGING}/*" "${PRODUCTION}/" 2>/dev/null || echo "No staging files found"

          # Make production files public
          gsutil -m acl ch -r -u AllUsers:R "${PRODUCTION}/" 2>/dev/null || true

          # Delete staging files
          gsutil -m rm -r "${STAGING}/" 2>/dev/null || echo "No staging files to delete"

          echo "::notice::Images promoted to production: ${PRODUCTION}"
