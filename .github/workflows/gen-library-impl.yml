name: "Gen: Library Implementation"
run-name: "Generate: ${{ inputs.library }} for ${{ inputs.spec_id }}"

# Reusable workflow - called once per library in parallel
on:
  workflow_call:
    inputs:
      spec_id:
        description: "The spec ID (e.g., scatter-basic)"
        required: true
        type: string
      library:
        description: "The library to generate for"
        required: true
        type: string
      main_issue_number:
        description: "Parent issue number"
        required: true
        type: string
      sub_issue_number:
        description: "Sub-issue number for this library"
        required: true
        type: string
      attempt:
        description: "Attempt number (1-3)"
        required: false
        type: number
        default: 1
      deps:
        description: "Library-specific dependencies"
        required: true
        type: string
      base_branch:
        description: "Base branch to create from (e.g., plot/{spec_id} or main)"
        required: false
        type: string
        default: "main"
    outputs:
      pr_number:
        description: "PR number created (if any)"
        value: ${{ jobs.generate.outputs.pr_number }}
      pr_exists:
        description: "Whether a PR was created"
        value: ${{ jobs.generate.outputs.pr_exists }}
    secrets:
      CLAUDE_CODE_OAUTH_TOKEN:
        required: true
      ANTHROPIC_API_KEY:
        required: false

jobs:
  generate:
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.pr.outputs.pr_number }}
      pr_exists: ${{ steps.pr.outputs.pr_exists }}
    permissions:
      contents: write
      pull-requests: write
      issues: write
      actions: read
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Update sub-issue status to generating
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue edit ${{ inputs.sub_issue_number }} \
            --remove-label "testing" \
            --remove-label "reviewing" \
            --remove-label "ai-approved" \
            --remove-label "ai-rejected" \
            --add-label "generating" 2>/dev/null || true

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.13'

      - name: Install uv
        uses: astral-sh/setup-uv@v7

      - name: Install library-specific dependencies
        run: |
          uv venv .venv
          source .venv/bin/activate
          uv pip install ${{ inputs.deps }} pandas>=2.2.0

      - name: Check for previous attempts in sub-issue
        id: previous_attempts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get all comments from sub-issue to provide context for AI
          COMMENTS=$(gh api repos/${{ github.repository }}/issues/${{ inputs.sub_issue_number }}/comments \
            --jq '[.[] | select(.body | contains("Attempt"))] | map(.body) | join("\n\n---\n\n")' 2>/dev/null || echo "")

          if [ -n "$COMMENTS" ]; then
            echo "has_history=true" >> $GITHUB_OUTPUT
            # Save to file for later use
            echo "$COMMENTS" > /tmp/previous_attempts.md
          else
            echo "has_history=false" >> $GITHUB_OUTPUT
          fi

      - name: Create branch for this library
        id: branch
        run: |
          BRANCH="auto/${{ inputs.spec_id }}/${{ inputs.library }}"
          BASE="${{ inputs.base_branch }}"

          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "base_branch=$BASE" >> $GITHUB_OUTPUT

          # Fetch base branch first
          git fetch origin "$BASE"

          # Check if library branch exists
          if git ls-remote --heads origin "$BRANCH" | grep -q "$BRANCH"; then
            git fetch origin "$BRANCH"
            git checkout "$BRANCH"
            echo "branch_exists=true" >> $GITHUB_OUTPUT
          else
            # Create new branch FROM the base branch (not main)
            git checkout -b "$BRANCH" "origin/$BASE"
            echo "branch_exists=false" >> $GITHUB_OUTPUT
          fi

          echo "::notice::Branch: $BRANCH (base: $BASE)"

      - name: Run Claude Code to generate implementation
        timeout-minutes: 60
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          claude_args: "--model opus"
          additional_permissions: |
            actions: read
          prompt: |
            ## Task: Generate ${{ inputs.library }} Implementation for ${{ inputs.spec_id }}

            You are generating ONLY the **${{ inputs.library }}** implementation. Focus exclusively on this library.

            ### Step 1: Read required files
            1. `prompts/plot-generator.md` - Base generation rules
            2. `prompts/default-style-guide.md` - Visual style requirements (colors, fonts, dimensions)
            3. `prompts/quality-criteria.md` - Quality requirements
            4. `prompts/library/${{ inputs.library }}.md` - Library-specific rules
            5. `specs/${{ inputs.spec_id }}.md` - The specification

            ### Step 2: Check for previous attempts
            ${{ steps.previous_attempts.outputs.has_history == 'true' && 'IMPORTANT: There are previous failed attempts. Read /tmp/previous_attempts.md to understand what went wrong and avoid repeating the same mistakes.' || 'This is the first attempt for this library.' }}

            ### Step 3: Generate implementation
            Create the implementation file at the correct path:
            - `plots/${{ inputs.library }}/{plot_type}/${{ inputs.spec_id }}/default.py`

            Determine {plot_type} from the spec (e.g., scatter, bar, line, heatmap).

            ### Step 4: Test the implementation
            Run the implementation to verify it works:
            ```bash
            source .venv/bin/activate
            MPLBACKEND=Agg python plots/${{ inputs.library }}/{plot_type}/${{ inputs.spec_id }}/default.py
            ```

            ### Step 5: Format the code
            IMPORTANT: Run ruff to format and lint the code before committing:
            ```bash
            uv run ruff format plots/${{ inputs.library }}/{plot_type}/${{ inputs.spec_id }}/default.py
            uv run ruff check --fix plots/${{ inputs.library }}/{plot_type}/${{ inputs.spec_id }}/default.py
            ```

            ### Step 6: Create PR (only if implementation is successful)
            - Branch: `auto/${{ inputs.spec_id }}/${{ inputs.library }}`
            - **Base:** `${{ inputs.base_branch }}` (IMPORTANT: use --base flag!)
            - Title: `feat(${{ inputs.library }}): implement ${{ inputs.spec_id }}`
            - Use this command:
              ```bash
              gh pr create --base "${{ inputs.base_branch }}" \
                --title "feat(${{ inputs.library }}): implement ${{ inputs.spec_id }}" \
                --body "## Summary
              Implements \`${{ inputs.spec_id }}\` for **${{ inputs.library }}** library.

              **Parent Issue:** #${{ inputs.main_issue_number }}
              **Sub-Issue:** #${{ inputs.sub_issue_number }}
              **Base Branch:** \`${{ inputs.base_branch }}\`
              **Attempt:** ${{ inputs.attempt }}/3

              ## Implementation
              - \`plots/${{ inputs.library }}/{plot_type}/${{ inputs.spec_id }}/default.py\`"
              ```

            ### Important
            - Focus ONLY on ${{ inputs.library }} - do not generate code for other libraries
            - If you cannot implement this plot type in ${{ inputs.library }}, explain why in the PR body
            - Document any limitations or workarounds in code comments

      - name: Get PR number
        id: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="auto/${{ inputs.spec_id }}/${{ inputs.library }}"
          BASE="${{ inputs.base_branch }}"
          PR_NUMBER=$(gh pr list --head "$BRANCH" --base "$BASE" --json number -q '.[0].number' 2>/dev/null || echo "")

          if [ -n "$PR_NUMBER" ]; then
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "pr_exists=true" >> $GITHUB_OUTPUT
          else
            echo "pr_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Update sub-issue with attempt details
        if: steps.pr.outputs.pr_exists == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SPEC_ID="${{ inputs.spec_id }}"
          LIBRARY="${{ inputs.library }}"
          ATTEMPT="${{ inputs.attempt }}"
          PR_NUMBER="${{ steps.pr.outputs.pr_number }}"

          # Find the generated plot file
          PLOT_FILE=$(find plots/$LIBRARY -name "default.py" -path "*/${SPEC_ID}/*" 2>/dev/null | head -1 || echo "")

          # Read the code if it exists
          if [ -f "$PLOT_FILE" ]; then
            CODE=$(cat "$PLOT_FILE")
          else
            CODE="No implementation file found"
          fi

          # Create attempt documentation comment
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Extract technical approach from code
          python3 << PYEOF
          import re

          code = '''$CODE'''

          approach_lines = []

          # 1. Extract all imports (full import lines)
          imports = []
          for line in code.split('\n'):
              if line.startswith('import ') or line.startswith('from '):
                  # Skip typing imports
                  if 'typing' not in line and 'TYPE_CHECKING' not in line:
                      imports.append(line.strip())

          if imports:
              approach_lines.append(f"**Imports:** \`{', '.join(imports[:3])}\`")

          # 2. Find main plot function call (e.g., ax.plot, sns.lineplot, px.line)
          plot_patterns = [
              (r'ax\.(plot|scatter|bar|hist|boxplot|violinplot|heatmap|imshow)\s*\(', 'matplotlib'),
              (r'plt\.(plot|scatter|bar|hist)\s*\(', 'matplotlib'),
              (r'sns\.(lineplot|scatterplot|barplot|histplot|boxplot|violinplot|heatmap|regplot)\s*\(', 'seaborn'),
              (r'px\.(line|scatter|bar|histogram|box|violin|imshow|density_heatmap)\s*\(', 'plotly'),
              (r'go\.(Scatter|Bar|Heatmap|Box|Violin)\s*\(', 'plotly'),
              (r'figure\.(line|circle|scatter|vbar|hbar|quad|rect)\s*\(', 'bokeh'),
              (r'alt\.(Chart|LayerChart)\s*\(', 'altair'),
              (r'(ggplot|geom_line|geom_point|geom_bar|geom_histogram|geom_boxplot)\s*\(', 'plotnine'),
              (r'pygal\.(Line|Bar|Pie|XY|Histogram|Box|Dot)\s*\(', 'pygal'),
              (r'(LineSeries|BarSeries|ScatterSeries|PieSeries)\s*\(', 'highcharts'),
          ]

          for pattern, lib in plot_patterns:
              match = re.search(pattern, code)
              if match:
                  approach_lines.append(f"**Plot function:** \`{match.group(0).rstrip('(')}\`")
                  break

          # 3. Extract create_plot function signature
          func_match = re.search(r'def create_plot\((.*?)\)\s*->', code, re.DOTALL)
          if func_match:
              params = func_match.group(1).strip()
              # Get first 3 params
              param_list = [p.strip().split(':')[0].strip() for p in params.split(',')[:4]]
              approach_lines.append(f"**Parameters:** \`{', '.join(param_list)}\`")

          # 4. Extract key styling/config (figsize, style, etc.)
          style_patterns = [
              (r"figsize\s*=\s*\(([^)]+)\)", "figsize"),
              (r"style\s*=\s*['\"]([^'\"]+)['\"]", "style"),
              (r"template\s*=\s*['\"]([^'\"]+)['\"]", "template"),
              (r"color\s*=\s*['\"]([^'\"]+)['\"]", "color"),
          ]

          styles = []
          for pattern, name in style_patterns:
              match = re.search(pattern, code)
              if match:
                  styles.append(f"{name}={match.group(1)}")

          if styles:
              approach_lines.append(f"**Config:** {', '.join(styles[:3])}")

          if not approach_lines:
              approach_lines = ["See PR for implementation details"]

          approach_text = '\n'.join(f"- {line}" for line in approach_lines)

          lines = [
              f"## Attempt $ATTEMPT/3",
              "",
              "### Technical Approach",
              approach_text,
              "",
              "### Status",
              f"- **PR:** #$PR_NUMBER",
              f"- **File:** \`$PLOT_FILE\`",
              f"- **Workflow:** [${{ github.run_id }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})",
              "",
              "---",
              ""
          ]
          comment = '\n'.join(lines)

          with open('/tmp/attempt_comment.md', 'w') as f:
              f.write(comment)
          PYEOF

          # Post to sub-issue
          gh issue comment ${{ inputs.sub_issue_number }} --body-file /tmp/attempt_comment.md

      - name: Update sub-issue label to testing
        if: steps.pr.outputs.pr_exists == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue edit ${{ inputs.sub_issue_number }} \
            --remove-label "generating" \
            --add-label "testing"
